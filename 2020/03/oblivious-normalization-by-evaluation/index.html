<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">

    <title>oblivious normalization by evaluation</title>

    <meta name="keywords" content="">
    <meta name="canonical" href="https://rmculpepper.github.io/blog/2020/03/oblivious-normalization-by-evaluation">
    <meta rel="alternate" type="application/atom+xml" title="Atom Feed"
          href="/blog/feeds/all.atom.xml">

    <link rel="next" href="/blog/2020/03/Jeremiah-was-a-Frog">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/blog/favicon.png">
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css"
          integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47"
          crossorigin="anonymous">
    <link rel="stylesheet"
          href="https://unpkg.com/purecss@1.0.1/build/grids-responsive-min.css"
          integrity="sha384-e+NM0rMilIXo+lz6+dXhoHMjd2iTSxNsCHpqkvuSBsAhwMDRF/Wn2QRRNaLxTcN/"
          crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="/blog/css/pure-blog.css">
    <link rel="stylesheet" type="text/css" href="/blog/css/pygments.css">
    <link rel="stylesheet" type="text/css" href="/blog/css/scribble.css">
    <link rel="stylesheet" type="text/css" href="/blog/css/custom.css">

  </head>
  <body>


    <div class="layout pure-g">
      <div class="titlebar pure-u-1">
        <div class="header">
          <h1 class="site-title"><a href="/blog/">One Racketeer</a></h1>

          <h2 class="site-tagline">the blog of Ryan Culpepper</h2>
          <h2 class="site-alt-tagline">
            (blog-of ryanc@racket-lang.org)
          </h2>
          <nav class="nav">
            <ul class="nav-list">
              <li class="nav-item">
                <a class="pure-button" href="/blog/tags/db.html">db</a>
              </li><li class="nav-item">
                     <a class="pure-button" href="/blog/tags/macros.html">macros</a>
                   </li><li class="nav-item">
                          <a class="pure-button" href="/blog/tags/racket.html">racket</a>
                        </li>
            </ul>
          </nav>
        </div>
      </div>
      <div class="content pure-u-1">

        <div class="content-inner">


          <article class="post">

  <header class="post-header">
    <h1 class="post-title">oblivious normalization by evaluation</h1>
    <div class="post-meta">
      <div class="authors">By: Ryan Culpepper</div>
      <span class="post-date"><time datetime="2020-03-20">2020-03-20</time></span>
      <span class="post-tags"></span>
    </div>
  </header>
  <p>At <a href="https://con.racket-lang.org/2018/">RacketCon 2018&rsquo;s</a>
<a href="https://github.com/racket/racket/wiki/2018-RacketCon-Office-Hours-Teams-&amp;-Workshops">office
hours</a>, <a href="http://davidchristiansen.dk/">David Thrane
Christiansen</a> talked about &ldquo;normalization by evaluation&rdquo; as a
prelude to his &ldquo;Implementing Dependent Types&rdquo; session.</p>
<p>In the design he sketched, the normalizer needed help from the
evaluator. I wondered if it was possible to use a standard (oblivious)
evaluator, such as Racket&rsquo;s normal <span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span>. The answer is no &#8212;<wbr></wbr>
but kind of.</p>
<h2><a name="(part._.Normal_forms)"></a>Normal forms</h2>
<p>To be precise, we are working with the following language:</p>
<p></p>
<table cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">EXP</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">X</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">EXP</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td></tr><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">X</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline">variable name</td></tr></tbody></table>
<p></p>
<div class="SIntrapara">A <span style="font-style: italic">normal form</span> (specifically, a &#946;-normal form) is a term that
does not contain any &#946;-redexes. That is, it does not contain any
subterm that the &#946; reduction rule can be applied to:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">[</span><span class="RktVar">EXP&#8322;</span><span class="hspace">&nbsp;</span>/<span class="hspace">&nbsp;</span><span class="RktVar">X</span><span class="RktPn">]</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#946;</span></p></div></div>
<div class="SIntrapara">where the notation _<span class="stt"> </span><span class="RktPn">[</span>_<span class="stt"> </span>/<span class="stt"> </span>_<span class="RktPn">]</span> means
capture-avoiding substitution.</div>
<p></p>
<div class="SIntrapara">The following terms are examples of normal forms:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<div class="SIntrapara">The following is <span style="font-style: italic">not</span> a normal form, even though it is a
<span style="font-style: italic">value</span> (we&rsquo;ll get back to values in a moment):
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></div></div>
<div class="SIntrapara">But the term above <span style="font-style: italic">has</span> a normal form (and our normalizer should
be able to find it):
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></p></div></div>
<div class="SIntrapara">We consider a term to have a normal form if we can convert it into a
normal form by applying the &#946; rule any number of times, anywhere in
the term (even within lambda-abstractions).</div>
<p></p>
<div class="SIntrapara">The following is not a normal form and does not have a normal form:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">usually called &#937;</span></p></div></div>
<p></p>
<div class="SIntrapara">Normal forms have the following shape, described by the <span class="RktVar">NF</span>
nonterminal:
</div>
<div class="SIntrapara"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">NF</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">NEU</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">NF</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td></tr><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">NEU</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">X</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">NEU</span><span class="hspace">&nbsp;</span><span class="RktVar">NF</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<div class="SIntrapara">A normal form is either a <span style="font-style: italic">neutral</span> term (<span class="RktVar">NEU</span>) or a
lambda-abstraction containing a normal form. A neutral is either a
variable or a neutral applied to a normal form. In other words, a
neutral term is a normal form that is not a lambda abstraction.</div>
<p>Note: In this post, whenever I say &ldquo;normal form&rdquo;, I always mean
&#946;-normal form; and whenever I say &ldquo;has a normal form&rdquo;, I mean it has
a &#946;-normal form <span style="font-style: italic">reachable through &#946; steps</span>. That is, even once I
introduce other kinds of steps, the idea of having a normal form is
tied to &#946;; when I talk about whether the normal form is reachable
through other kinds of steps, I&rsquo;ll say so explicitly.</p>
<h2><a name="(part._.C.B.N_.Evaluation)"></a>CBN Evaluation</h2>
<p>If we consistently apply the &#946; rule at the leftmost, outermost place
that it can be applied, except within a <span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span> body, then we
get <span style="font-style: italic">call-by-name (CBN) evaluation</span>.</p>
<p>Here&rsquo;s a simple CBN evaluator:</p>
<div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate : EXP &#8594; EXP</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">e1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">e2</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">x</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">e2</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">subst</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e1*</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">open term!</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">e1*</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">e2</span><span class="RktVal">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<p>Note that the evaluator allows open terms. For example, <span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span>
produces <span class="RktVal">'</span><span class="RktVal">x</span>. Also note that the evaluator diverges when given
a term like <span class="RktSym">&#937;</span>. If the original term is closed, then the
second inner <span class="RktSym">match</span> case is impossible, and the evaluator
either returns a lambda-abstraction or it diverges.</p>
<p>Given the CBN evaluator above, it is straightforward to write a
normalizer that takes a term and produces a normal form (if the term
has one). We start by evaluating the term, then we recur into its
immediate subexpressions and normalize them.</p>
<div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">normalize : EXP &#8594; NF</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">normalize</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">match</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">x</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">e</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">x</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">normalize</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">e1</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">e2</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">normalize</span><span class="hspace">&nbsp;</span><span class="RktSym">e1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">normalize</span><span class="hspace">&nbsp;</span><span class="RktSym">e2</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<h2><a name="(part._.C.B.V_.Evaluation)"></a>CBV Evaluation</h2>
<p></p>
<div class="SIntrapara">Evaluation in Racket, however, is not based on the &#946; rule, but on a
restricted form called &#946;<span style="vertical-align: sub; font-size: 80%">v</span> (&ldquo;&#946;-value&rdquo;):
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">VAL&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">[</span><span class="RktVar">VAL&#8322;</span><span class="hspace">&nbsp;</span>/<span class="hspace">&nbsp;</span><span class="RktVar">X</span><span class="RktPn">]</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#946;<span style="vertical-align: sub; font-size: 80%">v</span></span></p></div></div>
<div class="SIntrapara">where a <span style="font-style: italic">value</span> (<span class="RktVar">VAL</span>) is either a variable or a
lambda-abstraction:
</div>
<div class="SIntrapara"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">VAL</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">X</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<div class="SIntrapara">If we apply &#946;<span style="vertical-align: sub; font-size: 80%">v</span> at the leftmost, outermost place that it can be
applied, except within a <span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span> body, then we get
<span style="font-style: italic">call-by-value (CBV) evaluation</span>. (The terms &ldquo;call-by-name&rdquo;
and &ldquo;call-by-value&rdquo;, as evaluation strategies, are unrelated to the
terms &ldquo;call (or pass) by value&rdquo; and &ldquo;call (or pass) by reference&rdquo; used
in the context of languages like C, C++, Java, etc.)</div>
<p>Given these two differences, is it possible to build a &#946;-normalizer
out of a CBV-evaluator?</p>
<p></p>
<div class="SIntrapara">No. Not one that uses the evaluator in any meaningful way,
anyway. Consider the following term:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#937;</span><span class="RktPn">)</span></p></div></div>
<div class="SIntrapara">where <span class="RktSym">&#937;</span> is that example from earlier of a term without a
normal form. This term has a normal form: <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span>.</div>
<p>If we apply the evaluator to this term, it diverges (that
is, it fails to terminate). If we do case analysis first and apply the
evaluator to the subterms, it diverges on the second. We could do
deeper case analysis, but at that point, we&rsquo;re just building a
normalizer from scratch.</p>
<p>The problem is that while this example has a normal form (reachable in
one &#946; step), that normal form is not reachable through any number of
&#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps &#8212;<wbr></wbr> it gets trapped by <span class="RktSym">&#937;</span>. That shouldn&rsquo;t be
surprising: &#946;<span style="vertical-align: sub; font-size: 80%">v</span> is weaker than &#946;.</p>
<h2><a name="(part._.Un-evaluation)"></a>Un-evaluation</h2>
<p>Let&rsquo;s refine the question. If there is a normal form reachable through
&#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps, can we find it using a CBV evaluator? Racket&rsquo;s <span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span>
procedure, for example?</p>
<p>Now we must reckon with another issue: Racket&rsquo;s <span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span> takes an
encoding of a term (as an S-expression made of lists and symbols) and
produces a Racket value, and Racket provides no way to convert a
function value back to a term encoding. But perhaps we could build
such an &ldquo;un-evaluator&rdquo;, at least if we&rsquo;re allowed to assume that the
value we&rsquo;re un-evaluating corresponds to a normal form.</p>
<p></p>
<div class="SIntrapara">So let&rsquo;s try to build a normalizing un-evaluator, with the following
signature:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">un-eval : eval(NF) -&gt; NF</span></p></div></div>
<div class="SIntrapara">That is, <span class="RktSym">un-eval</span> must be given something that is (or is
&ldquo;equivalent&rdquo; to) the result of calling <span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span> on some
(closed) normal form, and it will return an equivalent normal form. Of
course, <span class="RktSym">un-eval</span> might choose different variable names. For
example, we might have the following:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">z</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">z</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr></tbody></table></div></div>
<p>The only possible value we can get from evaluating a closed normal
form is an ordinary Racket function, and the only thing we can do with
that is to apply it to an argument. So we should apply the function to
some sort of value that will allow us to map out its behavior.</p>
<p>For example, suppose we apply the function to the symbol <span class="RktVal">'</span><span class="RktVal">a</span>
and we get back <span class="RktVal">'</span><span class="RktVal">a</span>. Then we know that the function
corresponds to the normal form <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span> &#8212;<wbr></wbr> remember,
we&rsquo;re assuming that the function is the result of <span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span>ing
some term in the language above, so we don&rsquo;t consider possibilities
like <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">a</span><span class="RktPn">)</span> or <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29">if</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29">symbol?</a></span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">x</span><span class="stt"> </span><span class="RktVal">12</span><span class="RktPn">)</span><span class="RktPn">)</span>. But what if the function is like <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span> and doesn&rsquo;t return the symbol immediately? Or worse, what if
the function is like <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span> and tries to apply
its argument? Sending a symbol is not a good strategy.</p>
<p></p>
<div class="SIntrapara">We need to send a probe that acts like a function, but that we can
recognize and turn into a term encoding. Racket gives us many ways to
create such functions; here&rsquo;s one approach using applicable
structures:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29">prop:procedure</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">probe-term</span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<p>That is, a <span class="RktSym">probe</span> instance supports the operation
<span class="RktSym">probe-term</span> that returns an S-expression representation of the
term, but it also acts as a procedure of one argument. When applied, a
probe just creates a new probe whose term is an application term where
the operator is the original probe&rsquo;s term and the operand is a term
representing the argument. We convert the argument to a term using
<span class="RktSym">un-eval</span>, which we are about to define.</p>
<p>The <span class="RktSym">un-eval</span> function must handle two cases: ordinary Racket
functions that we want to un-eval, and probes that we have introduced
to explore the first kind of function. Since we can recognize probes
with the <span class="RktSym">probe?</span> predicate, we can implement <span class="RktSym">un-eval</span>
by case analysis:</p>
<div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">un-eval : eval(NF) -&gt; NF</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe-term</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._gensym%29%29">gensym</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">var</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<p>That is, to un-eval a probe, we just extract its term using
<span class="RktSym">probe-term</span>. To un-eval another kind of function, we first
generate a fresh variable name, then we return a lambda expression
with the fresh variable and a body constructed by probing the given
function.</p>
<p>We can now see how <span class="RktSym">un-eval</span> corresponds to the <span class="RktVar">NF</span>
grammar. A probe always carries a neutral term (<span class="RktVar">NEU</span>), and
<span class="RktSym">un-eval</span> returns either a neutral term (case 1) or a
lambda-abstraction whose body is a normal form (case 2).</p>
<div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (lambda (x3) ((x3 x2) x1)))))</span></p></td></tr></tbody></table></div>
<p></p>
<div class="SIntrapara">See <a href="https://github.com/rmculpepper/blog/blob/master/examples/2020/normalize-v1.rkt">this code</a> for a slightly nicer
implementation and more examples, including Church numerals and a
factorial function defined via the <span class="RktSym">Z</span>, the call-by-value
fixed-point combinator. For example, we have the following:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktSym">THREE</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (x1 (x1 x2)))))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktSym">THREE</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (x1 (x1 (x1 (x1 (x1 x2))))))))</span></p></td></tr></tbody></table></div></div>
<div class="SIntrapara">Note that <span class="RktSym">Z</span>, <span class="RktSym">fact</span>, and recursive functions in
general do not have normal forms, but <span class="RktPn">(</span><span class="RktSym">fact</span><span class="stt"> </span><span class="RktSym">THREE</span><span class="RktPn">)</span> is just a
Church numeral, and it has the normal form above (the Church encoding
of 6).</div>
<p></p>
<div class="SIntrapara">Sadly, <span class="RktSym">un-eval</span> cannot always find a normal form, even when
one exists. For example, it diverges on the following term:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<div class="SIntrapara">This term has the normal form <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">y</span><span class="RktPn">)</span>, but the normal
form is not reachable via &#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps.</div>
<p>So perhaps we can characterize <span class="RktSym">un-eval</span> with the following
statement: if <span class="RktVar">EXP</span> has a &#946;-normal form <span class="RktVar">NF</span> reachable
by a sequence of &#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps, then <span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29">quote</a></span><span class="stt"> </span><span class="RktVar">EXP</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span>
produces <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29">quote</a></span><span class="stt"> </span><span class="RktVar">NF</span><span class="RktPn">)</span> (modulo &#945;-renaming).</p>
<h2><a name="(part._.Beyond__v)"></a>Beyond &#946;<span style="vertical-align: sub; font-size: 80%">v</span></h2>
<p></p>
<div class="SIntrapara">But wait! Here&rsquo;s an interesting term that takes a function <span class="RktSym">f</span>,
applies it to itself, and then discards the result and just returns
<span class="RktSym">f</span>:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">interesting</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<div class="SIntrapara">or equivalently, with a little clarifying syntactic sugar:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">interesting</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<div class="SIntrapara">This term has the &#946;-normal form <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">f</span><span class="RktPn">)</span>, but the
normal form is not reachable through &#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps.</div>
<p>It&rsquo;s worth emphasizing here that while <span class="RktSym">interesting</span> and
<span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">f</span><span class="RktPn">)</span> are equivalent in the &#955;-calculus (generated by
&#946;), they are <span style="font-style: italic">not</span> equivalent in the &#955;&#7525;-calculus (generated by
&#946;<span style="vertical-align: sub; font-size: 80%">v</span>). They must not be, because under CBV evaluation <span style="font-style: italic">the two
terms act differently</span>! For example, <span class="RktPn">(</span><span class="RktSym">interesting</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span>
evaluates to <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span> and
<span class="RktPn">(</span><span class="RktSym">interesting</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">x</span><span class="stt"> </span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span> diverges.</p>
<p></p>
<div class="SIntrapara">But here&rsquo;s a surprise: <span class="RktSym">un-eval</span> calculates the &#946;-normal form
for this term:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktSym">interesting</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr></tbody></table></div></div>
<div class="SIntrapara">But how?</div>
<p></p>
<div class="SIntrapara">Our probing strategy has turned the inner <span class="RktPn">(</span><span class="RktSym">f</span><span class="stt"> </span><span class="RktSym">f</span><span class="RktPn">)</span> into a value
at the Racket level, even though it is not a value at the term
level. In general, any (closed) neutral term is represented by a
Racket value (a <span class="RktSym">probe</span> instance). So effectively we&rsquo;ve added
another notion of reduction to our evaluator:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">NEU&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">[</span><span class="RktVar">NEU&#8322;</span><span class="hspace">&nbsp;</span>/<span class="hspace">&nbsp;</span><span class="RktVar">X</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#946;<span style="vertical-align: sub; font-size: 80%">neu</span></span></p></div></div>
<p>If our purpose were to faithfully follow the restrictions of &#946;<span style="vertical-align: sub; font-size: 80%">v</span>
reduction, this should be alarming. But this whole adventure started
with the question of whether CBV-evaluation can simulate (or at least
approximate) &#946;-normalization, so let&rsquo;s see how far we can push it.</p>
<p></p>
<div class="SIntrapara">Recall the definition of neutral term (<span class="RktVar">NEU</span>):
</div>
<div class="SIntrapara"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">NEU</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">X</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">NEU</span><span class="hspace">&nbsp;</span><span class="RktVar">NF</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<div class="SIntrapara">Probes correspond to neutral terms: a base probe is created to
represent a variable when we create a <span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span> abstraction; and
when we extend a probe through application, we normalize the argument.</div>
<p>What do we lose by eagerly normalizing the argument?</p>
<p></p>
<div class="SIntrapara">Here&rsquo;s a weird term that takes a function <span class="RktSym">f</span>, applies it to a
value that doesn&rsquo;t have a normal form, throws away that result, and
then just returns <span class="RktSym">f</span>.
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">weird</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div></div>
<div class="SIntrapara">This term has the normal form <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">f</span><span class="RktPn">)</span>, but it is not
reachable through &#946;<span style="vertical-align: sub; font-size: 80%">v</span> steps. And indeed, <span class="RktSym">un-eval</span> diverges &#8212;<wbr></wbr>
but only because it tries calculating the normal form of the value
passed to <span class="RktSym">f</span>, even though that result is discarded.</div>
<p>This example suggests a modification to our probe representation:
delay the normalization of arguments until the probe&rsquo;s term is needed
for the body of a lambda-abstraction. Here are the updated definitions:</p>
<div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Probe is (probe (promise-of Neutral))</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term-p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29">prop:procedure</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">delay</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">probe-term</span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">probe-term : Probe -&gt; Neutral</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe-term</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">force</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe-term-p</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">un-eval+ : eval(NF) -&gt; NF</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28quote._~23~25kernel%29._if%29%29">if</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe?</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe-term</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/let.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._let%29%29">let</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">gensym*</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">lambda</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">var</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">probe</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">delay</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<p></p>
<div class="SIntrapara">The <a href="https://github.com/rmculpepper/blog/blob/master/examples/2020/normalize-v2.rkt">new <span class="RktSym">un-eval+</span></a> agrees
with the old version on the examples where the old one worked:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (lambda (x3) ((x3 x2) x1)))))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktSym">THREE</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (x1 (x1 x2)))))</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fact</span><span class="hspace">&nbsp;</span><span class="RktSym">THREE</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) (lambda (x2) (x1 (x1 (x1 (x1 (x1 (x1 x2))))))))</span></p></td></tr></tbody></table></div></div>
<div class="SIntrapara">And the new version of <span class="RktSym">un-eval</span> reports the &ldquo;expected&rdquo;
normal form for <span class="RktSym">weird</span>:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><table cellpadding="0" cellspacing="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">un-eval+</span><span class="hspace">&nbsp;</span><span class="RktSym">weird</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'(lambda (x1) x1)</span></p></td></tr></tbody></table></div></div>
<p></p>
<div class="SIntrapara">Now a <span class="RktSym">probe</span> instance corresponds to a term like a neutral
term but with value arguments (<span class="RktVar">NVAL</span>):
</div>
<div class="SIntrapara"><table cellpadding="0" cellspacing="0"><tbody><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">NVAL</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">X</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">NVAL</span><span class="hspace">&nbsp;</span><span class="RktVar">VAL</span><span class="RktPn">)</span></td></tr></tbody></table></div>
<div class="SIntrapara">and <span class="RktSym">un-eval+</span> effectively implements a new notion of
reduction:
</div>
<div class="SIntrapara"><div class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">X</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVar">NVAL&#8322;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">EXP&#8321;</span><span class="RktPn">[</span><span class="RktVar">NVAL&#8322;</span><span class="hspace">&nbsp;</span>/<span class="hspace">&nbsp;</span><span class="RktVar">X</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">&#946;<span style="vertical-align: sub; font-size: 80%">nval</span></span></p></div></div>
<p>I conjecture (but haven&rsquo;t proven) that <span class="RktSym">un-eval+</span> satisfies the
following property: If <span class="RktVar">EXP</span> has a &#946;-normal form <span class="RktVar">NF</span>
reachable by a sequence of &#946;<span style="vertical-align: sub; font-size: 80%">v</span> and &#946;<span style="vertical-align: sub; font-size: 80%">nval</span> steps, then
<span class="RktPn">(</span><span class="RktSym">un-eval</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/eval.html#%28def._%28%28quote._~23~25kernel%29._eval%29%29">eval</a></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29">quote</a></span><span class="stt"> </span><span class="RktVar">EXP</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span> produces <span class="RktPn">(</span><span class="RktSym"><a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/quote.html#%28form._%28%28quote._~23~25kernel%29._quote%29%29">quote</a></span><span class="stt"> </span><span class="RktVar">NF</span><span class="RktPn">)</span>
(modulo &#945;-renaming).</p>
  <footer>

    <nav class="post-navigation" aria-label="Post Navigation">
  <div class="pure-menu">
  <ul class="pure-menu-list">

    <li class="pure-menu-item">
      <a class="pure-menu-link" href="/blog/2020/03/Jeremiah-was-a-Frog"
         aria-label="Next">
        <span aria-hidden="true">Jeremiah was a Frog &rarr;</span>
      </a>
    </li>
  </ul>
  </div>
</nav>

  </footer>

</article>


        </div>
        <div class="page-copyright">
          <div class="page-copyright-icon">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
              <img alt="Creative Commons License" style="border-width:0"
                   src="/blog/img/cc4-by-sa-88x31.png" /></a>
          </div>
          <div class="page-copyright-text">
            Copyright 2020 Ryan Culpepper.
            This work is licensed under a
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
            Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          </div>
        </div>
      </div>
    </div>

  </body>
</html>