<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><title type="text">One Racketeer: TITLE</title><author><name>Ryan Culpepper</name></author><link rel="self" href="https://rmculpepper.github.io/blog/feeds/racket.atom.xml"/><link rel="alternate" href="https://rmculpepper.github.io/blog/tags/racket.html"/><id>tag:rmculpepper.github.io,2020:blog:feeds/racket.atom.xml</id><updated>2020-03-16T23:00:00Z</updated><entry><title type="text">Jeremiah was a Frog</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2020/03/Jeremiah-was-a-Frog"/><id>tag:rmculpepper.github.io,2020:blog:2020/03/Jeremiah-was-a-Frog</id><published>2020-03-16T23:00:00Z</published><updated>2020-03-16T23:00:00Z</updated><content type="html">&lt;p&gt;I&amp;rsquo;m rebooting my blog, previously
&lt;a href="https://macrologist.blogspot.com/"&gt;hosted on Blogspot&lt;/a&gt;. I finished
a conversion to &lt;a href="https://github.com/greghendershott/frog"&gt;Frog&lt;/a&gt; some time ago &amp;#8212;&lt;wbr&gt;&lt;/wbr&gt; there weren&amp;rsquo;t that many posts to
convert, and I was already using Scribble and my now-defunct tool
&lt;a href="https://blog.racket-lang.org/2012/04/scribble-your-blogs.html"&gt;Scriblogify&lt;/a&gt;.
But there was just one thing I wanted to fix about Frog&amp;rsquo;s Scribble rendering
first. And then there was another thing, and so on, and in the end I wound up
with something different enough to give it a new name.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2020/03/Jeremiah-was-a-Frog"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">new syntax template features</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2018/11/new-syntax-template-features"/><id>tag:rmculpepper.github.io,2020:blog:2018/11/new-syntax-template-features</id><published>2018-11-21T23:00:00Z</published><updated>2018-11-21T23:00:00Z</updated><content type="html">&lt;p&gt;In Racket 7, the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt; form supports two new template subforms:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~40%29%29"&gt;~@&lt;/a&gt;&lt;/span&gt; (&amp;ldquo;splice&amp;rdquo;) splices the result of its subtemplate (which must
produce a syntax list) into the enclosing list template, and&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~3f%29%29"&gt;~?&lt;/a&gt;&lt;/span&gt; (&amp;ldquo;try&amp;rdquo;) chooses between alternative subtemplates depending
on whether their pattern variables have &amp;ldquo;absent&amp;rdquo; values.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;These features originated in &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28mod-path._syntax%2Fparse%2Fexperimental%2Ftemplate%29"&gt;&lt;span class="RktSym"&gt;syntax/parse/experimental/template&lt;/span&gt;&lt;/a&gt;:
the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._template%29%29"&gt;template&lt;/a&gt;&lt;/span&gt; form was like an extended version of &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt;, and
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._~3f~40%29%29"&gt;?@&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._~3f~3f%29%29"&gt;??&lt;/a&gt;&lt;/span&gt; were the splicing forms and the try/else template
forms, respectively. The names were changed to &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~40%29%29"&gt;~@&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~3f%29%29"&gt;~?&lt;/a&gt;&lt;/span&gt; to
avoid name collisions with other libraries. In Racket 7, the old
&lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28mod-path._syntax%2Fparse%2Fexperimental%2Ftemplate%29"&gt;&lt;span class="RktSym"&gt;syntax/parse/experimental/template&lt;/span&gt;&lt;/a&gt; library just exports the new
standard forms under the old names (that is, it exports &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt; under
the name &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._template%29%29"&gt;template&lt;/a&gt;&lt;/span&gt;, and so on).&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2018/11/new-syntax-template-features"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">define vs attach</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2013/06/define-vs-attach"/><id>tag:rmculpepper.github.io,2020:blog:2013/06/define-vs-attach</id><published>2013-06-04T22:00:00Z</published><updated>2013-06-04T22:00:00Z</updated><content type="html">&lt;p&gt;Racket&amp;rsquo;s macro system gives macros two ways of associating
&lt;span style="font-style: italic"&gt;static&lt;/span&gt; (or &lt;span style="font-style: italic"&gt;compile-time&lt;/span&gt;) information with a particular
name. One way is to &lt;span style="font-style: italic"&gt;define&lt;/span&gt; the name as the static information;
the other is to &lt;span style="font-style: italic"&gt;attach&lt;/span&gt; the information to the already-defined
name.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2013/06/define-vs-attach"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">avoid flushing your wire protocol's performance down the pipes</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes"/><id>tag:rmculpepper.github.io,2020:blog:2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes</id><published>2012-03-15T23:00:00Z</published><updated>2012-03-15T23:00:00Z</updated><content type="html">&lt;p&gt;When implementing a wire protocol, one occasionally needs to know something
about the wires. This blog post is the story of how the placement of a call to
&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/port-buffers.html#%28def._%28%28quote._~23~25kernel%29._flush-output%29%29"&gt;flush-output&lt;/a&gt;&lt;/span&gt; caused a &lt;span style="font-style: italic"&gt;factor-of-20&lt;/span&gt; variation in performance.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">unprepared queries vs statement caching</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2012/02/unprepared-queries-vs-statement-caching"/><id>tag:rmculpepper.github.io,2020:blog:2012/02/unprepared-queries-vs-statement-caching</id><published>2012-02-08T23:00:00Z</published><updated>2012-02-08T23:00:00Z</updated><content type="html">&lt;p&gt;Racket&amp;rsquo;s &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/index.html"&gt;&lt;span class="RktSym"&gt;db&lt;/span&gt;&lt;/a&gt; library supports parameterized queries
where the SQL is given as a string (that is, &lt;a name="(tech._unprepared)"&gt;&lt;/a&gt;&lt;span style="font-style: italic"&gt;unprepared&lt;/span&gt;):&lt;/p&gt;
&lt;div class="SCodeFlow"&gt;&lt;p&gt;&lt;span class="RktPn"&gt;(&lt;/span&gt;&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/query-api.html#%28def._%28%28lib._db%2Fbase..rkt%29._query-list%29%29"&gt;query-list&lt;/a&gt;&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktSym"&gt;c&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktVal"&gt;"SELECT field1 FROM table WHERE field2 = ?"&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktVal"&gt;17&lt;/span&gt;&lt;span class="RktPn"&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;This is handled by an implicit call to &lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/query-api.html#%28def._%28%28lib._db%2Fbase..rkt%29._prepare%29%29"&gt;prepare&lt;/a&gt;&lt;/span&gt;, which turns
the string into a prepared statement; the prepared statement is then
executed with the arguments.&lt;/p&gt;
&lt;p&gt;The problem with this approach is that it involves two trips to the
server: one to prepare and one to execute. One trip would be
better. In this post I discuss two techniques for eliminating
extraneous server trips. I&amp;rsquo;ve recently added one of them to Racket;
the other turns out to be problematic.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2012/02/unprepared-queries-vs-statement-caching"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">in praise of PostgreSQL arrays</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/10/in-praise-of-PostgreSQL-arrays"/><id>tag:rmculpepper.github.io,2020:blog:2011/10/in-praise-of-PostgreSQL-arrays</id><published>2011-10-30T23:00:00Z</published><updated>2011-10-30T23:00:00Z</updated><content type="html">&lt;p&gt;I just added support for
&lt;a href="http://www.postgresql.org/docs/current/static/arrays.html"&gt;PostgreSQL
arrays&lt;/a&gt; to the &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/index.html"&gt;&lt;span class="RktSym"&gt;db&lt;/span&gt;&lt;/a&gt; library. While there are some uses
of arrays that are iffy from a database design standpoint, there&amp;rsquo;s one
use that weighs overwhelmingly in their favor: avoiding dynamic
generation of SQL &lt;span class="stt"&gt;IN&lt;/span&gt; comparisons.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/10/in-praise-of-PostgreSQL-arrays"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">lazy module loading</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/10/lazy-module-loading"/><id>tag:rmculpepper.github.io,2020:blog:2011/10/lazy-module-loading</id><published>2011-10-15T22:00:00Z</published><updated>2011-10-15T22:00:00Z</updated><content type="html">&lt;p&gt;The Racket module system is good at managing dependencies. When you
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/require.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._require%29%29"&gt;require&lt;/a&gt;&lt;/span&gt; a module, you ensure that that module is initialized
before your code runs, and when the other module changes, the compiler
will notice and recompile your module too. Racket even stratifies
dependencies according to &lt;a class="Sq" data-pltdoc="x" href="https://docs.racket-lang.org/guide/stx-phases.html"&gt;phase
levels&lt;/a&gt; so you can use some modules in your macro implementations and
other modules in your run-time code and the expander/compiler/linker
knows
&lt;a href="http://www.cs.utah.edu/plt/publications/macromod.pdf"&gt;what
you want when&lt;/a&gt;. It keeps track and makes sure that everything is
loaded and available when it&amp;rsquo;s supposed to be.&lt;/p&gt;
&lt;p&gt;But sometimes you want to manage dependencies yourself. This post
is about how to &lt;span style="font-style: italic"&gt;lazily load&lt;/span&gt; the implementations of functions
and&amp;#8212;&lt;wbr&gt;&lt;/wbr&gt;with a bit of care&amp;#8212;&lt;wbr&gt;&lt;/wbr&gt;even macros.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/10/lazy-module-loading"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">definitions vs enclosing binding forms</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/09/definitions-vs-enclosing-binding-forms"/><id>tag:rmculpepper.github.io,2020:blog:2011/09/definitions-vs-enclosing-binding-forms</id><published>2011-09-26T22:00:00Z</published><updated>2011-09-26T22:00:00Z</updated><content type="html">&lt;p&gt;There are two kinds of binding forms in Racket: definitions and
enclosing binding forms. The scope of a binding introduced by an
enclosing binding form is entirely evident: it&amp;rsquo;s one (or more) of the
form&amp;rsquo;s sub-terms. For example, in&lt;/p&gt;
&lt;div class="SCodeFlow"&gt;&lt;p&gt;&lt;span class="RktPn"&gt;(&lt;/span&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29"&gt;lambda&lt;/a&gt;&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktPn"&gt;(&lt;/span&gt;&lt;span class="RktVar"&gt;var&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="RktPn"&gt;)&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktVar"&gt;body&lt;/span&gt;&lt;span class="RktPn"&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;the scope of the &lt;span class="RktVar"&gt;var&lt;/span&gt; bindings is &lt;span class="RktVar"&gt;body&lt;/span&gt;. In
contrast, the scope of a definition is determined by its context: the
enclosing &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29"&gt;lambda&lt;/a&gt;&lt;/span&gt; body, for example, or the enclosing
module&amp;#8212;&lt;wbr&gt;&lt;/wbr&gt;except that scope is too simple a term for how bindings work
in such contexts. Enclosing binding forms are simpler and cleaner but
weaker; definition forms are more powerful, but have a more
complicated binding structure. Definitions also have the pleasant
property of reducing rightward code drift.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/09/definitions-vs-enclosing-binding-forms"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">syntax-parse and literals</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals"/><id>tag:rmculpepper.github.io,2020:blog:2011/09/syntax-parse-and-literals</id><published>2011-09-08T22:00:00Z</published><updated>2011-09-08T22:00:00Z</updated><content type="html">&lt;p&gt;In &lt;a href="/blog/2011/09/macros-and-literals"&gt;my
last post&lt;/a&gt;, I talked about macros and referential auxiliary
identifiers&amp;#8212;&lt;wbr&gt;&lt;/wbr&gt;what we usually call a macro&amp;rsquo;s &amp;ldquo;literals.&amp;rdquo; Scheme
macro systems only get it half right, though, because while they
compare identifiers using referential equality (i.e., using the
&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stxcmp.html#%28def._%28%28quote._~23~25kernel%29._free-identifier~3d~3f%29%29"&gt;free-identifier=?&lt;/a&gt;&lt;/span&gt; predicate), they allow literals to refer to
nonexistent bindings. While the comparison is well-defined via the
definition of &lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stxcmp.html#%28def._%28%28quote._~23~25kernel%29._free-identifier~3d~3f%29%29"&gt;free-identifier=?&lt;/a&gt;&lt;/span&gt;, at a higher level the idea
is nonsensical.&lt;/p&gt;
&lt;p&gt;In contrast, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; requires that every literal
refer to some binding. (I&amp;rsquo;ll sometimes refer to this requirement as
the &lt;span style="font-style: italic"&gt;is-bound&lt;/span&gt; property for short.) This requirement is
problematic in a different way. Specifically, this property cannot be
checked statically (that is, when the syntax-parse expression
containing the literal is compiled).&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">macros and literals</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/09/macros-and-literals"/><id>tag:rmculpepper.github.io,2020:blog:2011/09/macros-and-literals</id><published>2011-09-06T22:00:00Z</published><updated>2011-09-06T22:00:00Z</updated><content type="html">&lt;p&gt;Macros often have associated auxiliary identifiers (sometimes called
&lt;span style="font-style: italic"&gt;keywords&lt;/span&gt; or &lt;span style="font-style: italic"&gt;reserved words&lt;/span&gt;, although both terms are
problematic in Racket). For example, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29"&gt;cond&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt;;
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29"&gt;class&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._public%29%29"&gt;public&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._private%29%29"&gt;private&lt;/a&gt;&lt;/span&gt;, etc;
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._unit%29%29"&gt;unit&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._import%29%29"&gt;import&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._export%29%29"&gt;export&lt;/a&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The fundamental question is what constitutes a use of an auxiliary
identifier, and there are two reasonable answers: &lt;span style="font-style: italic"&gt;symbolic
equality&lt;/span&gt; and &lt;span style="font-style: italic"&gt;referential equality&lt;/span&gt;. By symbolic equality I
mean, for example, that any identifier written with exactly the
letters &lt;span class="stt"&gt;else&lt;/span&gt; is accepted as an &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt; auxiliary form. By
referential equality I mean any identifier that &lt;span style="font-style: italic"&gt;refers to&lt;/span&gt;
(using the standard notions of binding, environments, etc) the binding
identified as the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt; binding.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/09/macros-and-literals"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">macros, parameters; binding, and reference</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2006/04/macros-parameters-binding-and-reference"/><id>tag:rmculpepper.github.io,2020:blog:2006/04/macros-parameters-binding-and-reference</id><published>2006-04-07T22:00:00Z</published><updated>2006-04-07T22:00:00Z</updated><content type="html">&lt;p&gt;Danny Yoo had an interesting question on the plt-scheme mailing list
recently. At first it seemed like your standard non-hygienic, &amp;ldquo;I want
this to mean something in here&amp;rdquo; macro question. I used to group
macros into three levels of &amp;ldquo;hygienicness&amp;rdquo;: the hygienic ones, the
ones that are morally hygienic in that the names they introduce are
based on their input, and the totally non-hygienic ones that have a
fixed name that they stick into the program. An example of the middle
set is &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-struct%29%29"&gt;define-struct&lt;/a&gt;&lt;/span&gt;, and an example of the third set is a
loop construct that binds the name &lt;span class="RktKw"&gt;yield&lt;/span&gt; in its body.&lt;/p&gt;
&lt;p&gt;The third class used to offend me from a purist&amp;rsquo;s (semi-purist?)
perspective. But it&amp;rsquo;s a very reasonable thing to want to do. Consider
the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29"&gt;class&lt;/a&gt;&lt;/span&gt; macro and the names it uses to do interesting
things: &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super%29%29"&gt;super&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._public%29%29"&gt;public&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._field%29%29"&gt;field&lt;/a&gt;&lt;/span&gt;,
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._init%29%29"&gt;init&lt;/a&gt;&lt;/span&gt;, and so on. It depends on those particular names.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2006/04/macros-parameters-binding-and-reference"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry></feed>