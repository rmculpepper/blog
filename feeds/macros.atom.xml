<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><title type="text">One Racketeer: TITLE</title><author><name>Ryan Culpepper</name></author><link rel="self" href="https://rmculpepper.github.io/blog/feeds/macros.atom.xml"/><link rel="alternate" href="https://rmculpepper.github.io/blog/tags/macros.html"/><id>tag:rmculpepper.github.io,2020:blog:feeds/macros.atom.xml</id><updated>2018-11-22T12:00:00Z</updated><entry><title type="text">new syntax template features</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2018/11/new-syntax-template-features"/><id>tag:rmculpepper.github.io,2020:blog:2018/11/new-syntax-template-features</id><published>2018-11-22T12:00:00Z</published><updated>2018-11-22T12:00:00Z</updated><content type="html">&lt;p&gt;In Racket 7, the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt; form supports two new template subforms:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~40%29%29"&gt;~@&lt;/a&gt;&lt;/span&gt; (&amp;ldquo;splice&amp;rdquo;) splices the result of its subtemplate (which must
produce a syntax list) into the enclosing list template, and&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~3f%29%29"&gt;~?&lt;/a&gt;&lt;/span&gt; (&amp;ldquo;try&amp;rdquo;) chooses between alternative subtemplates depending
on whether their pattern variables have &amp;ldquo;absent&amp;rdquo; values.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;These features originated in &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28mod-path._syntax%2Fparse%2Fexperimental%2Ftemplate%29"&gt;&lt;span class="RktSym"&gt;syntax/parse/experimental/template&lt;/span&gt;&lt;/a&gt;:
the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._template%29%29"&gt;template&lt;/a&gt;&lt;/span&gt; form was like an extended version of &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt;, and
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._~3f~40%29%29"&gt;?@&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._~3f~3f%29%29"&gt;??&lt;/a&gt;&lt;/span&gt; were the splicing forms and the try/else template
forms, respectively. The names were changed to &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~40%29%29"&gt;~@&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._~7e~3f%29%29"&gt;~?&lt;/a&gt;&lt;/span&gt; to
avoid name collisions with other libraries. In Racket 7, the old
&lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28mod-path._syntax%2Fparse%2Fexperimental%2Ftemplate%29"&gt;&lt;span class="RktSym"&gt;syntax/parse/experimental/template&lt;/span&gt;&lt;/a&gt; library just exports the new
standard forms under the old names (that is, it exports &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._syntax%29%29"&gt;syntax&lt;/a&gt;&lt;/span&gt; under
the name &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Ftemplate..rkt%29._template%29%29"&gt;template&lt;/a&gt;&lt;/span&gt;, and so on).&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2018/11/new-syntax-template-features"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">syntax-parse and literals</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals"/><id>tag:rmculpepper.github.io,2020:blog:2011/09/syntax-parse-and-literals</id><published>2011-09-09T12:00:00Z</published><updated>2011-09-09T12:00:00Z</updated><content type="html">&lt;p&gt;In &lt;a href="/blog/2011/09/macros-and-literals"&gt;my
last post&lt;/a&gt;, I talked about macros and referential auxiliary
identifiers&amp;#8212;&lt;wbr&gt;&lt;/wbr&gt;what we usually call a macro&amp;rsquo;s &amp;ldquo;literals.&amp;rdquo; Scheme
macro systems only get it half right, though, because while they
compare identifiers using referential equality (i.e., using the
&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stxcmp.html#%28def._%28%28quote._~23~25kernel%29._free-identifier~3d~3f%29%29"&gt;free-identifier=?&lt;/a&gt;&lt;/span&gt; predicate), they allow literals to refer to
nonexistent bindings. While the comparison is well-defined via the
definition of &lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/stxcmp.html#%28def._%28%28quote._~23~25kernel%29._free-identifier~3d~3f%29%29"&gt;free-identifier=?&lt;/a&gt;&lt;/span&gt;, at a higher level the idea
is nonsensical.&lt;/p&gt;
&lt;p&gt;In contrast, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/syntax/Parsing_Syntax.html#%28form._%28%28lib._syntax%2Fparse..rkt%29._syntax-parse%29%29"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; requires that every literal
refer to some binding. (I&amp;rsquo;ll sometimes refer to this requirement as
the &lt;span style="font-style: italic"&gt;is-bound&lt;/span&gt; property for short.) This requirement is
problematic in a different way. Specifically, this property cannot be
checked statically (that is, when the syntax-parse expression
containing the literal is compiled).&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/09/syntax-parse-and-literals"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">macros and literals</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/09/macros-and-literals"/><id>tag:rmculpepper.github.io,2020:blog:2011/09/macros-and-literals</id><published>2011-09-07T12:00:00Z</published><updated>2011-09-07T12:00:00Z</updated><content type="html">&lt;p&gt;Macros often have associated auxiliary identifiers (sometimes called
&lt;span style="font-style: italic"&gt;keywords&lt;/span&gt; or &lt;span style="font-style: italic"&gt;reserved words&lt;/span&gt;, although both terms are
problematic in Racket). For example, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29"&gt;cond&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt;;
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29"&gt;class&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._public%29%29"&gt;public&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._private%29%29"&gt;private&lt;/a&gt;&lt;/span&gt;, etc;
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._unit%29%29"&gt;unit&lt;/a&gt;&lt;/span&gt; has &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._import%29%29"&gt;import&lt;/a&gt;&lt;/span&gt; and &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/creatingunits.html#%28form._%28%28lib._racket%2Funit..rkt%29._export%29%29"&gt;export&lt;/a&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The fundamental question is what constitutes a use of an auxiliary
identifier, and there are two reasonable answers: &lt;span style="font-style: italic"&gt;symbolic
equality&lt;/span&gt; and &lt;span style="font-style: italic"&gt;referential equality&lt;/span&gt;. By symbolic equality I
mean, for example, that any identifier written with exactly the
letters &lt;span class="stt"&gt;else&lt;/span&gt; is accepted as an &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt; auxiliary form. By
referential equality I mean any identifier that &lt;span style="font-style: italic"&gt;refers to&lt;/span&gt;
(using the standard notions of binding, environments, etc) the binding
identified as the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29"&gt;else&lt;/a&gt;&lt;/span&gt; binding.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/09/macros-and-literals"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">macros, parameters; binding, and reference</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2006/04/macros-parameters-binding-and-reference"/><id>tag:rmculpepper.github.io,2020:blog:2006/04/macros-parameters-binding-and-reference</id><published>2006-04-08T12:00:00Z</published><updated>2006-04-08T12:00:00Z</updated><content type="html">&lt;p&gt;Danny Yoo had an interesting question on the plt-scheme mailing list
recently. At first it seemed like your standard non-hygienic, &amp;ldquo;I want
this to mean something in here&amp;rdquo; macro question. I used to group
macros into three levels of &amp;ldquo;hygienicness&amp;rdquo;: the hygienic ones, the
ones that are morally hygienic in that the names they introduce are
based on their input, and the totally non-hygienic ones that have a
fixed name that they stick into the program. An example of the middle
set is &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define-struct%29%29"&gt;define-struct&lt;/a&gt;&lt;/span&gt;, and an example of the third set is a
loop construct that binds the name &lt;span class="RktKw"&gt;yield&lt;/span&gt; in its body.&lt;/p&gt;
&lt;p&gt;The third class used to offend me from a purist&amp;rsquo;s (semi-purist?)
perspective. But it&amp;rsquo;s a very reasonable thing to want to do. Consider
the &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._class%29%29"&gt;class&lt;/a&gt;&lt;/span&gt; macro and the names it uses to do interesting
things: &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._super%29%29"&gt;super&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._public%29%29"&gt;public&lt;/a&gt;&lt;/span&gt;, &lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._field%29%29"&gt;field&lt;/a&gt;&lt;/span&gt;,
&lt;span class="RktSym"&gt;&lt;a class="RktStxLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/createclass.html#%28form._%28%28lib._racket%2Fprivate%2Fclass-internal..rkt%29._init%29%29"&gt;init&lt;/a&gt;&lt;/span&gt;, and so on. It depends on those particular names.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2006/04/macros-parameters-binding-and-reference"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry></feed>