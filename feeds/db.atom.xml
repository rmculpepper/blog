<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><title type="text">One Racketeer: TITLE</title><author><name>Ryan Culpepper</name></author><link rel="self" href="https://rmculpepper.github.io/blog/feeds/db.atom.xml"/><link rel="alternate" href="https://rmculpepper.github.io/blog/tags/db.html"/><id>tag:rmculpepper.github.io,2020:blog:feeds/db.atom.xml</id><updated>2012-03-15T23:00:00Z</updated><entry><title type="text">avoid flushing your wire protocol's performance down the pipes</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes"/><id>tag:rmculpepper.github.io,2020:blog:2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes</id><published>2012-03-15T23:00:00Z</published><updated>2012-03-15T23:00:00Z</updated><content type="html">&lt;p&gt;When implementing a wire protocol, one occasionally needs to know something
about the wires. This blog post is the story of how the placement of a call to
&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/reference/port-buffers.html#%28def._%28%28quote._~23~25kernel%29._flush-output%29%29"&gt;flush-output&lt;/a&gt;&lt;/span&gt; caused a &lt;span style="font-style: italic"&gt;factor-of-20&lt;/span&gt; variation in performance.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2012/03/avoid-flushing-your-wire-protocol-s-performance-down-the-pipes"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">unprepared queries vs statement caching</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2012/02/unprepared-queries-vs-statement-caching"/><id>tag:rmculpepper.github.io,2020:blog:2012/02/unprepared-queries-vs-statement-caching</id><published>2012-02-08T23:00:00Z</published><updated>2012-02-08T23:00:00Z</updated><content type="html">&lt;p&gt;Racket&amp;rsquo;s &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/index.html"&gt;&lt;span class="RktSym"&gt;db&lt;/span&gt;&lt;/a&gt; library supports parameterized queries
where the SQL is given as a string (that is, &lt;a name="(tech._unprepared)"&gt;&lt;/a&gt;&lt;span style="font-style: italic"&gt;unprepared&lt;/span&gt;):&lt;/p&gt;
&lt;div class="SCodeFlow"&gt;&lt;p&gt;&lt;span class="RktPn"&gt;(&lt;/span&gt;&lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/query-api.html#%28def._%28%28lib._db%2Fbase..rkt%29._query-list%29%29"&gt;query-list&lt;/a&gt;&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktSym"&gt;c&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktVal"&gt;"SELECT field1 FROM table WHERE field2 = ?"&lt;/span&gt;&lt;span class="hspace"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="RktVal"&gt;17&lt;/span&gt;&lt;span class="RktPn"&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;This is handled by an implicit call to &lt;span class="RktSym"&gt;&lt;a class="RktValLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/query-api.html#%28def._%28%28lib._db%2Fbase..rkt%29._prepare%29%29"&gt;prepare&lt;/a&gt;&lt;/span&gt;, which turns
the string into a prepared statement; the prepared statement is then
executed with the arguments.&lt;/p&gt;
&lt;p&gt;The problem with this approach is that it involves two trips to the
server: one to prepare and one to execute. One trip would be
better. In this post I discuss two techniques for eliminating
extraneous server trips. I&amp;rsquo;ve recently added one of them to Racket;
the other turns out to be problematic.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2012/02/unprepared-queries-vs-statement-caching"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry><entry><title type="text">in praise of PostgreSQL arrays</title><link rel="alternate" href="https://rmculpepper.github.io/blog/2011/10/in-praise-of-PostgreSQL-arrays"/><id>tag:rmculpepper.github.io,2020:blog:2011/10/in-praise-of-PostgreSQL-arrays</id><published>2011-10-30T23:00:00Z</published><updated>2011-10-30T23:00:00Z</updated><content type="html">&lt;p&gt;I just added support for
&lt;a href="http://www.postgresql.org/docs/current/static/arrays.html"&gt;PostgreSQL
arrays&lt;/a&gt; to the &lt;a class="RktModLink Sq" data-pltdoc="x" href="https://docs.racket-lang.org/db/index.html"&gt;&lt;span class="RktSym"&gt;db&lt;/span&gt;&lt;/a&gt; library. While there are some uses
of arrays that are iffy from a database design standpoint, there&amp;rsquo;s one
use that weighs overwhelmingly in their favor: avoiding dynamic
generation of SQL &lt;span class="stt"&gt;IN&lt;/span&gt; comparisons.&lt;/p&gt;&lt;a href="https://rmculpepper.github.io/blog/2011/10/in-praise-of-PostgreSQL-arrays"&gt;&lt;em&gt;More&amp;hellip;&lt;/em&gt;&lt;/a&gt;</content></entry></feed>